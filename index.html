<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Log App</title>
    
    <!-- FAVICON: Pen emoji (üñäÔ∏è) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üñäÔ∏è</text></svg>">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General professional font */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom styling for the pulsing effect when recording */
        .voice-recording {
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-red {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); /* Standard Red Pulse */
            }
            50% {
                box-shadow: 0 0 0 10px rgba(220, 38, 38, 0);
            }
        }

        /* Custom style for the Save button (Light Gray #D3D3D3) */
        .bg-custom-save-gray {
            background-color: #D3D3D3;
        }
        .hover\:bg-custom-save-gray-hover:hover {
            /* Slightly darker gray for hover effect: #C0C0C0 */
            background-color: #C0C0C0; 
        }

        /* Custom style for the Video button (Medium Gray #A8A9AD) */
        .bg-custom-video-green {
            background-color: #A8A9AD;
            color: #1f2937; /* dark text for high contrast */
        }
        .hover\:bg-custom-video-green-hover:hover {
            /* Slightly darker gray for hover effect: #96979A */
            background-color: #96979A; 
            color: #1f2937;
        }

        /* Custom style for the Photo button (Dark Slate Blue #4863A0) */
        .bg-custom-photo-blue {
            background-color: #4863A0;
            color: white; /* Ensure text is white */
        }
        .hover\:bg-custom-photo-blue-hover:hover {
            /* Slightly darker blue for hover effect */
            background-color: #395085; 
        }
    </style>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <!-- Lucide Icons for Buttons -->
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body class="min-h-screen bg-gray-50 p-4 sm:p-8">

<div class="max-w-xl mx-auto">
    <header class="text-center mb-6">
        <h1 class="text-3xl font-bold text-gray-800">Daily Log</h1>
        <p class="text-gray-500">Capture your day using text, voice, photos, or video.</p>
        <p id="user-status" class="text-xs mt-1 text-gray-400"></p>
    </header>

    <!-- Input Section -->
    <section class="bg-white p-6 rounded-lg shadow-md mb-8 border border-gray-200">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">New Entry</h2>
        
        <div id="error-message" class="hidden p-3 bg-red-50 text-red-600 border border-red-200 rounded-md mb-4 font-medium text-sm"></div>
        <div id="status-message" class="hidden p-3 bg-blue-50 text-blue-600 border border-blue-200 rounded-md mb-4 font-medium text-sm"></div>
        
        <!-- Project Dropdown -->
        <div class="mb-3">
            <label for="project-select" class="block text-sm font-medium text-gray-700 mb-1">Assign to Project:</label>
            <select id="project-select" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 bg-white">
                <option value="" disabled selected>Loading projects...</option>
            </select>
        </div>

        <textarea id="log-text" class="w-full p-3 h-24 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 resize-none" placeholder="Type your thoughts here, or use the buttons below..."></textarea>
        
        <!-- Translation Output Area -->
        <div id="translation-output" class="hidden mt-4 p-3 bg-gray-100 border border-gray-300 rounded-md">
            <h3 class="text-sm font-semibold mb-1 text-gray-700 flex items-center">
                <i data-lucide="languages" class="w-4 h-4 mr-1"></i> Translation Result:
            </h3>
            <p id="translation-text" class="text-sm text-gray-800"></p>
        </div>
        
        <!-- Media Preview Area -->
        <div id="media-preview" class="mt-4 p-3 border border-gray-300 rounded-md hidden bg-gray-50">
            <h3 class="text-sm font-medium mb-2 text-gray-500">Media Attached:</h3>
            <!-- Content will be injected here -->
        </div>


        <div class="flex flex-wrap gap-2 mt-4">
            <!-- Voice Dictation Button (Red) -->
            <button id="voice-button" class="flex-1 min-w-[100px] flex items-center justify-center p-3 bg-red-600 text-white font-medium rounded-md hover:bg-red-700 transition disabled:opacity-50 text-sm" title="Start Voice Dictation">
                <i data-lucide="mic" class="w-4 h-4 mr-1"></i> 
                <span id="voice-label">Start Voice</span>
            </button>
            
            <!-- Photo Upload Button (DARK SLATE BLUE #4863A0) -->
            <button id="photo-button" class="flex-1 min-w-[100px] flex items-center justify-center p-3 bg-custom-photo-blue text-white font-medium rounded-md hover:bg-custom-photo-blue-hover transition disabled:opacity-50 text-sm" title="Upload Photo">
                <i data-lucide="camera" class="w-4 h-4 mr-1"></i> 
                Photo
            </button>
            <input type="file" id="photo-input" accept="image/*" class="hidden">

            <!-- Video Upload Button (Medium Gray #A8A9AD) -->
            <button id="video-button" class="flex-1 min-w-[100px] flex items-center justify-center p-3 bg-custom-video-green text-gray-900 font-medium rounded-md hover:bg-custom-video-green-hover transition disabled:opacity-50 text-sm" title="Upload Video">
                <i data-lucide="video" class="w-4 h-4 mr-1"></i> 
                Video
            </button>
            <input type="file" id="video-input" accept="video/*" class="hidden">

            <!-- Save Button (Light Gray #D3D3D3) -->
            <button id="save-button" class="w-full flex-grow flex items-center justify-center p-3 bg-custom-save-gray text-gray-900 font-semibold rounded-md hover:bg-custom-save-gray-hover transition disabled:opacity-50 mt-2 text-base" disabled>
                <i data-lucide="save" class="w-5 h-5 mr-2"></i> 
                Save Log
            </button>
        </div>
    </section>

    <!-- Log History Section -->
    <section class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Log History</h2>
        <div id="log-history" class="space-y-4">
            <p id="loading-logs" class="text-center text-gray-500">Loading logs...</p>
        </div>
    </section>
</div>

<!-- Firebase SDK Imports (MUST be type="module") -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, serverTimestamp, deleteDoc, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Global Variables (Provided by Canvas Environment) ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";
    const apiKey = ""; // API key is provided by the canvas environment for the fetch call
    
    // --- State and DOM Elements ---
    let db, auth, userId = null;
    let isAuthReady = false;
    let currentMedia = null; // Stores { type: 'image'/'video', data: base64_string }
    let projects = {}; // Store project lookup { id: name }
    
    // Voice recognition related variables
    let recognition = null;
    let isRecording = false;

    const logTextEl = document.getElementById('log-text');
    const projectSelectEl = document.getElementById('project-select');
    const saveButtonEl = document.getElementById('save-button');
    const voiceButtonEl = document.getElementById('voice-button');
    const photoButtonEl = document.getElementById('photo-button');
    const photoInputEl = document.getElementById('photo-input');
    const videoButtonEl = document.getElementById('video-button');
    const videoInputEl = document.getElementById('video-input');
    const logHistoryEl = document.getElementById('log-history');
    const mediaPreviewEl = document.getElementById('media-preview');
    const userStatusEl = document.getElementById('user-status');
    const voiceLabelEl = document.getElementById('voice-label');
    const errorEl = document.getElementById('error-message');
    const statusEl = document.getElementById('status-message');
    const translationOutputEl = document.getElementById('translation-output');
    const translationTextEl = document.getElementById('translation-text');
    
    // --- Utility Functions ---

    const showMessage = (element, message, isError = false) => {
        element.textContent = message;
        element.classList.remove('hidden');
        // Reset classes to ensure only one style is applied
        element.className = element.className.split(' ').filter(c => !c.startsWith('bg-') && !c.startsWith('text-') && !c.startsWith('border-')).join(' ');
        element.classList.add('p-3', 'rounded-md', 'mb-4', 'font-medium', 'text-sm');

        if (isError) {
            element.classList.add('bg-red-50', 'text-red-600', 'border', 'border-red-200');
        } else {
            element.classList.add('bg-blue-50', 'text-blue-600', 'border', 'border-blue-200');
        }
        setTimeout(() => element.classList.add('hidden'), 5000);
    };

    const setError = (message) => showMessage(errorEl, message, true);
    const setStatus = (message) => showMessage(statusEl, message, false);

    const checkSaveEnablement = () => {
        const hasText = logTextEl.value.trim().length > 0;
        const hasMedia = currentMedia !== null;
        const hasProject = projectSelectEl.value.length > 0;
        saveButtonEl.disabled = !(hasText || hasMedia) || !hasProject;
        
        // Hide translation output if text is cleared
        if (!hasText) {
             translationOutputEl.classList.add('hidden');
             translationTextEl.textContent = '';
        }
    };

    const getFirestorePath = (collectionName, docId) => {
        const base = `/artifacts/${appId}/users/${userId}/${collectionName}`;
        // When docId is null/undefined, this returns a CollectionReference, otherwise a DocumentReference
        return docId ? doc(db, base, docId) : collection(db, base);
    };
    
    const timeAgo = (timestamp) => {
        if (!timestamp) return 'Time unknown';
        const seconds = Math.floor((new Date() - timestamp.toDate()) / 1000);
        
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " years ago";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " months ago";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " days ago";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " hours ago";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " minutes ago";
        return Math.floor(seconds) + " seconds ago";
    };

    const formatTimestamp = (timestamp) => {
        if (!timestamp) return 'No Date';
        const date = timestamp.toDate();
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    };

    // --- Media and File Handling ---

    const handleFileChange = (event, type) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = () => {
            currentMedia = {
                type: type,
                data: reader.result
            };
            displayMediaPreview();
            checkSaveEnablement();
        };
        reader.onerror = () => {
            setError('Failed to read file.');
            currentMedia = null;
        };
        reader.readAsDataURL(file);
    };

    const displayMediaPreview = () => {
        mediaPreviewEl.innerHTML = '';
        if (currentMedia) {
            mediaPreviewEl.classList.remove('hidden');
            let content;
            if (currentMedia.type === 'image') {
                content = `
                    <img src="${currentMedia.data}" class="w-full max-h-48 object-contain rounded-md border border-gray-200" alt="Attached Image">
                `;
            } else if (currentMedia.type === 'video') {
                content = `
                    <video controls src="${currentMedia.data}" class="w-full max-h-48 object-contain rounded-md border border-gray-200">
                        Your browser does not support the video tag.
                    </video>
                `;
            }

            mediaPreviewEl.innerHTML = `
                <h3 class="text-sm font-medium mb-2 text-gray-500">Media Attached (${currentMedia.type}):</h3>
                ${content}
                <button onclick="window.removeMedia()" class="mt-2 text-red-500 hover:text-red-700 text-xs font-medium">Remove Media</button>
            `;
            // Ensure Lucide icons are rendered if needed here, though not strictly required for media content.
            if (typeof lucide !== 'undefined') lucide.createIcons();
        } else {
            mediaPreviewEl.classList.add('hidden');
        }
    };
    
    // Expose removeMedia to the window object so it can be called from the inline HTML button
    window.removeMedia = () => {
        currentMedia = null;
        photoInputEl.value = null; // Clear file inputs
        videoInputEl.value = null;
        displayMediaPreview();
        checkSaveEnablement();
    };
    
    // --- API Interaction (Translation) ---
    
    // Implementing exponential backoff for API calls
    const fetchWithBackoff = async (url, options, maxRetries = 5) => {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            } catch (error) {
                if (attempt < maxRetries - 1) {
                    const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s, 8s, 16s
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    throw error;
                }
            }
        }
    };

    const translateAndSummarize = async (text) => {
        const prompt = `Analyze the following user log entry. If the text is in a language other than English, translate it to clear, professional English. If the text is already English, provide a one-sentence, concise summary. 
        
        Log Entry: "${text}"`;
        
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            systemInstruction: {
                parts: [{ text: "You are a helpful, concise AI language assistant that provides only the requested translation or summary." }]
            }
        };

        const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        };
        
        try {
            const result = await fetchWithBackoff(`${GEMINI_API_URL}?key=${apiKey}`, options);
            const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (generatedText) {
                translationTextEl.textContent = generatedText;
                translationOutputEl.classList.remove('hidden');
            } else {
                translationTextEl.textContent = "Could not generate analysis or translation.";
                translationOutputEl.classList.remove('hidden');
            }
        } catch (error) {
            console.error('Gemini API call failed:', error);
            setError('Failed to get analysis/translation from AI service.');
            translationTextEl.textContent = "AI service connection error.";
            translationOutputEl.classList.remove('hidden');
        }
    };

    // --- Firebase Logic (Auth, Setup, Data) ---

    const ensureTestProjectExists = async () => {
        if (!userId) {
            console.error("Cannot ensure test project: userId is not set.");
            return;
        }

        const projectsRef = getFirestorePath('projects');
        const defaultProjectId = 'default-project';
        const defaultProjectDocRef = doc(projectsRef, defaultProjectId);
        
        try {
            const docSnap = await getDoc(defaultProjectDocRef);
            
            if (!docSnap.exists()) {
                await setDoc(defaultProjectDocRef, {
                    name: "My First Log Project",
                    createdAt: serverTimestamp(),
                    isDefault: true
                });
                console.log("Default project created successfully.");
            } else {
                console.log("Default project already exists.");
            }
        } catch (e) {
            console.error("Error ensuring test project exists:", e);
        }
    };

    const setupFirebase = async () => {
        if (Object.keys(firebaseConfig).length === 0) {
             setError("Firebase configuration is missing. Cannot initialize app.");
             return;
        }

        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        // Sign in using the custom token if available, otherwise anonymously
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Firebase Auth Error:", error);
            setError("Authentication failed. Please check the logs.");
        }

        // Auth state observer (runs once on sign-in/sign-out)
        onAuthStateChanged(auth, (user) => {
            (async () => { // <--- IIFE to allow use of await
                if (user) {
                    userId = user.uid;
                    userStatusEl.textContent = `User ID: ${userId}`;
                    isAuthReady = true;
                    
                    // 1. AWAIT the project creation check/creation
                    await ensureTestProjectExists();

                    // 2. Start listening to data now that the default project is guaranteed to exist
                    listenToProjects();
                    listenToLogs();
                } else {
                    userStatusEl.textContent = `User ID: Unauthorized (using a temporary ID)`;
                    userId = crypto.randomUUID();
                    isAuthReady = true;
                    // If not authenticated, we still start listeners, but they might be limited by security rules
                    listenToProjects();
                    listenToLogs();
                }
            })();
        });
    };

    const listenToProjects = () => {
        if (!db || !isAuthReady) return;
        
        // Define the path to the user's projects collection
        const projectsRef = getFirestorePath('projects');
        const q = query(projectsRef);

        onSnapshot(q, (snapshot) => {
            projects = {};
            // Start with a clean list, but keep the initial prompt visible if no projects are found
            const currentSelectedValue = projectSelectEl.value;
            projectSelectEl.innerHTML = '<option value="" disabled selected>Select a Project</option>';
            
            snapshot.forEach((doc) => {
                const data = doc.data();
                projects[doc.id] = data.name;
                const option = document.createElement('option');
                option.value = doc.id;
                option.textContent = data.name;
                projectSelectEl.appendChild(option);
            });
            
            // Re-select the previously selected project or auto-select the default
            if (currentSelectedValue && projects[currentSelectedValue]) {
                projectSelectEl.value = currentSelectedValue;
            } else {
                const defaultId = Object.keys(projects).find(id => projects[id] === "My First Log Project");
                if (defaultId) {
                    projectSelectEl.value = defaultId;
                }
            }

            // If projects are loaded but none is selected (shouldn't happen with the default project logic)
            if (projectSelectEl.value === '') {
                 projectSelectEl.querySelector('option[disabled]').selected = true;
            }
            
            checkSaveEnablement(); // Re-check if projects are loaded
        }, (error) => {
            console.error("Error fetching projects:", error);
            setError("Failed to load projects. Check console.");
        });
    };

    const listenToLogs = () => {
        if (!db || !isAuthReady) return;

        const logsRef = getFirestorePath('logs');
        const q = query(logsRef); // Can add `where` or `orderBy` if needed, but avoiding `orderBy` per guidelines.

        onSnapshot(q, (snapshot) => {
            logHistoryEl.innerHTML = '';
            
            if (snapshot.empty) {
                logHistoryEl.innerHTML = '<p class="text-center text-gray-500 p-4">No logs recorded yet.</p>';
                return;
            }
            
            // Convert to array and sort by timestamp in memory (descending)
            const logs = [];
            snapshot.forEach(doc => {
                logs.push({ id: doc.id, ...doc.data() });
            });
            
            logs.sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0));

            logs.forEach(log => {
                const logCard = createLogCard(log);
                logHistoryEl.appendChild(logCard);
            });
            
            // Render Lucide icons in the new cards
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
        }, (error) => {
            console.error("Error fetching logs:", error);
            setError("Failed to load log history. Check console.");
        });
    };
    
    // --- UI Component Generation ---
    
    const createLogCard = (log) => {
        const card = document.createElement('div');
        card.className = 'p-4 bg-gray-50 rounded-lg shadow-inner border border-gray-200';
        
        // Use a null check for log.projectId as projects might still be loading initially
        const projectName = log.projectId ? projects[log.projectId] || 'Unknown Project' : 'No Project';

        let mediaContent = '';
        if (log.media && log.media.data) { // Ensure media data exists
            const mediaType = log.media.type;
            const mediaData = log.media.data;
            if (mediaType === 'image') {
                mediaContent = `
                    <div class="mt-3">
                        <img src="${mediaData}" class="w-full max-h-48 object-cover rounded-md border border-gray-300" alt="Log Image">
                    </div>
                `;
            } else if (mediaType === 'video') {
                mediaContent = `
                    <div class="mt-3">
                        <video controls src="${mediaData}" class="w-full max-h-48 object-cover rounded-md border border-gray-300">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                `;
            }
        }
        
        card.innerHTML = `
            <div class="flex justify-between items-start mb-2">
                <div>
                    <span class="inline-block px-3 py-1 text-xs font-semibold rounded-full bg-blue-100 text-blue-800">${projectName}</span>
                </div>
                <button data-log-id="${log.id}" class="delete-log-btn text-red-500 hover:text-red-700 transition" title="Delete Log">
                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                </button>
            </div>
            <p class="text-gray-800 mb-3 whitespace-pre-wrap">${log.text || 'No text content.'}</p>
            ${mediaContent}
            <div class="mt-3 text-xs text-gray-500 flex justify-between">
                <span>Logged: ${formatTimestamp(log.timestamp)}</span>
                <span>(${timeAgo(log.timestamp)})</span>
            </div>
        `;
        
        const deleteBtn = card.querySelector('.delete-log-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', () => deleteLog(log.id));
        }
        return card;
    };
    
    // --- Actions ---

    const saveLog = async () => {
        if (!userId || !db) {
            setError("Database not initialized. Please wait or refresh.");
            return;
        }

        const text = logTextEl.value.trim();
        const projectId = projectSelectEl.value;
        
        if (!text && !currentMedia) {
            setError('Log must contain text or attached media.');
            return;
        }
        if (!projectId) {
            setError('Please select a project before saving.');
            return;
        }

        setStatus('Saving log entry...');
        saveButtonEl.disabled = true;

        try {
            const logsRef = getFirestorePath('logs');
            await addDoc(logsRef, {
                userId: userId,
                text: text,
                media: currentMedia, // currentMedia is null or { type, data }
                projectId: projectId,
                timestamp: serverTimestamp()
            });

            // Clear the form and state
            logTextEl.value = '';
            currentMedia = null;
            photoInputEl.value = null;
            videoInputEl.value = null;
            displayMediaPreview();
            translationOutputEl.classList.add('hidden');
            translationTextEl.textContent = '';
            
            setStatus('Log successfully saved!');

        } catch (e) {
            console.error("Error adding document: ", e);
            setError(`Failed to save log: ${e.message || 'Unknown error'}`);
        } finally {
            checkSaveEnablement(); // Re-enable if conditions are met
        }
    };
    
    const deleteLog = async (logId) => {
        if (!userId || !db || !logId) return;

        // NOTE: Using a custom UI confirm instead of browser's confirm()
        if (window.confirm("Are you sure you want to delete this log entry?")) {
            try {
                const logDocRef = getFirestorePath('logs', logId);
                await deleteDoc(logDocRef);
                setStatus('Log deleted successfully.');
            } catch (e) {
                console.error("Error deleting document: ", e);
                setError(`Failed to delete log: ${e.message || 'Unknown error'}`);
            }
        }
    };

    // --- Voice Dictation Setup ---
    
    const setupVoiceRecognition = () => {
        // Check for browser compatibility
        if (!('webkitSpeechRecognition' in window)) {
            voiceButtonEl.disabled = true;
            voiceLabelEl.textContent = 'Voice Not Supported';
            voiceButtonEl.classList.replace('bg-red-600', 'bg-gray-400');
            return;
        }

        recognition = new webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            let finalTranscript = '';
            let interimTranscript = '';
            
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    finalTranscript += event.results[i][0].transcript;
                } else {
                    interimTranscript += event.results[i][0].transcript;
                }
            }
            // Append interim results to the textarea for live feedback
            logTextEl.value = finalTranscript + interimTranscript;
            checkSaveEnablement();
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            setError(`Voice Error: ${event.error}. Try again.`);
            toggleRecording(false);
        };

        recognition.onend = () => {
            if (isRecording) {
                // Restart if it stopped unexpectedly while recording flag is true
                recognition.start();
            } else {
                 // Finalize the text after manual stop
                 logTextEl.value = logTextEl.value.trim();
                 checkSaveEnablement();
            }
        };
    };

    const toggleRecording = (start) => {
        if (!recognition) return;
        
        isRecording = start;
        
        if (start) {
            try {
                recognition.start();
                voiceLabelEl.textContent = 'Stop Recording';
                voiceButtonEl.classList.add('voice-recording');
                setStatus('Listening... say something!');
            } catch (e) {
                // Catch error if recognition is already running
                if (e.name !== 'InvalidStateError') {
                    console.error("Error starting recognition:", e);
                    setError("Could not start microphone.");
                    isRecording = false; // Reset state
                }
            }
        } else {
            recognition.stop();
            voiceLabelEl.textContent = 'Start Voice';
            voiceButtonEl.classList.remove('voice-recording');
            
            // Trigger translation/summary if text was recorded
            if (logTextEl.value.trim()) {
                 translateAndSummarize(logTextEl.value.trim());
            }
        }
    };

    // --- Event Listeners and Initialization ---

    const setupEventListeners = () => {
        saveButtonEl.addEventListener('click', saveLog);
        logTextEl.addEventListener('input', checkSaveEnablement);
        projectSelectEl.addEventListener('change', checkSaveEnablement);
        
        // Listen for log text changes to trigger AI analysis/translation
        logTextEl.addEventListener('blur', () => {
            const text = logTextEl.value.trim();
            if (text.length > 0 && !isRecording) {
                translateAndSummarize(text);
            }
        });

        // Media Button handlers
        photoButtonEl.addEventListener('click', () => photoInputEl.click());
        photoInputEl.addEventListener('change', (e) => handleFileChange(e, 'image'));
        videoButtonEl.addEventListener('click', () => videoInputEl.click());
        videoInputEl.addEventListener('change', (e) => handleFileChange(e, 'video'));
        
        // Voice Button handler
        voiceButtonEl.addEventListener('click', () => toggleRecording(!isRecording));
    };

    // Wait for the DOM to fully load before initializing
    document.addEventListener('DOMContentLoaded', () => {
        setupEventListeners();
        setupVoiceRecognition();
        setupFirebase();
        // Render initial Lucide icons
        if (typeof lucide !== 'undefined') lucide.createIcons();
    });
</script>
</body>
</html>
