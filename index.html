<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Dictation Log App</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load React, ReactDOM, and Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Lucide Icons for React -->
    <script type="module">
      import * as lucide from 'https://unpkg.com/lucide-react@0.292.0/dist/lucide-react.js';
      window.lucide = lucide;
    </script>
    <!-- Load Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Expose Firebase functions to the global window object for the Babel script to use
        window.firebase = {
            initializeApp,
            getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, addDoc, onSnapshot, collection, query, serverTimestamp
        };
    </script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
      body { font-family: 'Inter', sans-serif; background-color: #f9fafb; }
      .log-entry { transition: transform 0.3s ease-out, opacity 0.3s ease-out; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Use global variables and functions exposed by the CDN imports
        const { useState, useEffect, useRef } = React;
        const { createRoot } = ReactDOM;
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, addDoc, onSnapshot, collection, query, serverTimestamp } = window.firebase;
        const { Mic, Save, Loader, XCircle, List, User } = window.lucide;
        
        // --- Global Variables for Canvas Environment ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Configure Speech Recognition compatibility
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const isSpeechRecognitionSupported = !!SpeechRecognition;

        /**
         * Main application component for the Daily Dictation Log.
         */
        const App = () => {
          const [db, setDb] = useState(null);
          const [auth, setAuth] = useState(null);
          const [userId, setUserId] = useState(null);
          const [isAuthReady, setIsAuthReady] = useState(false);

          const [logEntries, setLogEntries] = useState([]);
          const [dictatedText, setDictatedText] = useState('');
          const [isRecording, setIsRecording] = useState(false);
          const [error, setError] = useState(null);
          const [statusMessage, setStatusMessage] = useState('');

          // Ref to hold the Speech Recognition instance
          const recognitionRef = useRef(null);

          // --- 1. Firebase Initialization and Authentication ---
          useEffect(() => {
            if (!firebaseConfig) {
              setError('Firebase configuration is missing. Cannot initialize database.');
              return;
            }

            try {
              const app = initializeApp(firebaseConfig);
              const authInstance = getAuth(app);
              const dbInstance = getFirestore(app);

              setAuth(authInstance);
              setDb(dbInstance);

              // Handle initial authentication state
              const authenticate = async () => {
                if (initialAuthToken) {
                  await signInWithCustomToken(authInstance, initialAuthToken);
                } else {
                  await signInAnonymously(authInstance);
                }
              };

              // Set up auth state change listener
              const unsubscribe = onAuthStateChanged(authInstance, (user) => {
                if (user) {
                  setUserId(user.uid);
                  setIsAuthReady(true);
                } else {
                  setUserId('unauthenticated');
                  setIsAuthReady(true);
                }
              });

              authenticate().catch((e) => {
                console.error("Firebase Auth Error:", e);
                setError("Authentication failed.");
                setUserId('auth-error');
                setIsAuthReady(true);
              });

              return () => unsubscribe();
            } catch (e) {
              console.error("Firebase Initialization Error:", e);
              setError('Failed to initialize Firebase.');
            }
          }, []);

          // --- 2. Firestore Listener for Real-Time Log Entries ---
          useEffect(() => {
            if (!isAuthReady || !db || !userId || userId === 'auth-error') return;

            const logsCollectionRef = collection(db, 'artifacts', appId, 'users', userId, 'daily_logs');
            const q = query(logsCollectionRef);

            // Set up real-time listener
            const unsubscribe = onSnapshot(q, (snapshot) => {
              const entries = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data(),
                // Ensure timestamp is handled (it can be Firestore's Timestamp or a Date/null)
                createdAt: doc.data().createdAt ? doc.data().createdAt.toDate() : new Date(),
              })).sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()); // Sort newest first

              setLogEntries(entries);
              setStatusMessage(`Found ${entries.length} log entries.`);
            }, (e) => {
              console.error("Firestore Snapshot Error:", e);
              setError("Failed to fetch log entries from Firestore.");
            });

            return () => unsubscribe();
          }, [isAuthReady, db, userId]);

          // --- 3. Save Function ---
          const saveDictatedText = async () => {
            if (!dictatedText.trim() || !db || !userId) return;

            const logsCollectionRef = collection(db, 'artifacts', appId, 'users', userId, 'daily_logs');

            try {
              await addDoc(logsCollectionRef, {
                text: dictatedText.trim(),
                createdAt: serverTimestamp(),
                // Add a raw timestamp for sorting if serverTimestamp is pending
                sortTimestamp: Date.now(),
              });
              setDictatedText('');
              setStatusMessage('Log entry saved successfully!');
            } catch (e) {
              console.error('Error saving document:', e);
              setError('Could not save the entry. Check console for details.');
            }
          };

          // --- 4. Voice Dictation Functions ---

          const startDictation = () => {
            if (!isSpeechRecognitionSupported) {
              setError('Your browser does not support the Web Speech API.');
              return;
            }

            if (recognitionRef.current) {
              recognitionRef.current.stop();
            }

            const recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
              setIsRecording(true);
              setError(null);
              setStatusMessage('Listening...');
            };

            recognition.onresult = (event) => {
              let interimTranscript = '';
              let finalTranscript = '';

              for (let i = event.resultIndex; i < event.results.length; ++i) {
                const transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                  finalTranscript += transcript + ' ';
                } else {
                  interimTranscript += transcript;
                }
              }

              setDictatedText(prevText => {
                // This logic prevents the text from accumulating old interim text incorrectly
                const baseText = prevText.split('\n')[0].trim();
                const newText = (baseText + ' ' + finalTranscript + interimTranscript).trim();
                return newText;
              });
            };

            recognition.onerror = (event) => {
              console.error('Speech Recognition Error:', event.error);
              setIsRecording(false);
              if (event.error === 'not-allowed') {
                setError('Microphone permission denied. Please enable it in your browser settings.');
              } else if (event.error === 'no-speech') {
                setStatusMessage('No speech detected. Try again.');
              } else {
                setError(`Dictation error: ${event.error}`);
              }
            };

            recognition.onend = () => {
              if (isRecording) {
                 setIsRecording(false);
                 setStatusMessage('Dictation paused.');
              }
            };

            recognitionRef.current = recognition;
            recognition.start();
          };

          const stopDictation = () => {
            if (recognitionRef.current) {
              recognitionRef.current.stop();
              setIsRecording(false);
              setStatusMessage('Recording stopped. Ready to save.');
            }
          };

          // --- 5. Loading and Error UI ---
          const LoadingIndicator = () => (
            <div className="flex justify-center items-center p-4">
              <Loader className="animate-spin mr-2 h-5 w-5 text-indigo-500" />
              <span className="text-gray-600">Loading application...</span>
            </div>
          );

          const ErrorDisplay = ({ message }) => (
            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow-sm mb-4 flex items-center">
                <XCircle className="h-5 w-5 mr-2" />
                <p className="font-medium">{message}</p>
            </div>
          );

          if (error) {
            return <ErrorDisplay message={error} />;
          }

          if (!isAuthReady) {
            return <LoadingIndicator />;
          }

          // --- 6. JSX Structure ---
          return (
            <div className="min-h-screen bg-gray-50 p-4 sm:p-8 font-sans">
              
              {/* Header and Status */}
              <header className="mb-8 bg-white p-4 rounded-xl shadow-lg">
                <h1 className="text-3xl font-extrabold text-gray-900 flex items-center">
                  <Mic className="text-indigo-600 mr-2 h-8 w-8" />
                  Voice Log Tester
                </h1>
                <p className="text-sm text-gray-500 mt-1">{statusMessage || 'App loaded. Start dictating to begin your test.'}</p>
                <div className="mt-2 text-xs text-gray-500 flex items-center">
                    <User className="h-4 w-4 mr-1" />
                    **Current User ID:** <span className="font-mono text-indigo-600 ml-1 break-all">{userId}</span>
                </div>
              </header>


              {/* Dictation Input Section */}
              <section className="bg-white p-6 rounded-xl shadow-lg mb-8">
                <h2 className="text-xl font-semibold text-gray-800 mb-4">Dictation Pad</h2>

                {!isSpeechRecognitionSupported && (
                     <ErrorDisplay message="Voice dictation (Web Speech API) is not available in your browser." />
                )}

                <textarea
                  className={`w-full p-3 border ${isRecording ? 'border-red-500 ring-4 ring-red-200' : 'border-gray-300'} rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-all`}
                  rows="5"
                  placeholder={isRecording ? 'Listening...' : 'Dictated text will appear here. Press the mic button to start.'}
                  value={dictatedText}
                  onChange={(e) => setDictatedText(e.target.value)}
                  disabled={isRecording}
                />

                <div className="flex space-x-4 mt-4">
                  <button
                    onClick={isRecording ? stopDictation : startDictation}
                    disabled={!isSpeechRecognitionSupported}
                    className={`flex-1 flex items-center justify-center px-6 py-3 rounded-xl font-bold text-white transition-all transform shadow-md ${
                      isRecording
                        ? 'bg-red-500 hover:bg-red-600 active:scale-95'
                        : 'bg-indigo-600 hover:bg-indigo-700 active:scale-95'
                    } disabled:opacity-50 disabled:cursor-not-allowed`}
                  >
                    {isRecording ? (
                      <span className="flex items-center"><Loader className="animate-spin h-5 w-5 mr-2" /> Stop Recording</span>
                    ) : (
                      <span className="flex items-center"><Mic className="h-5 w-5 mr-2" /> Start Dictation</span>
                    )}
                  </button>

                  <button
                    onClick={saveDictatedText}
                    disabled={!dictatedText.trim() || isRecording}
                    className="flex-1 flex items-center justify-center px-6 py-3 rounded-xl font-bold text-white bg-green-500 hover:bg-green-600 active:scale-95 transition-all transform shadow-md disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    <Save className="h-5 w-5 mr-2" />
                    Save to Log
                  </button>
                </div>
              </section>

              {/* Daily Log Overview Section */}
              <section className="bg-white p-6 rounded-xl shadow-lg">
                <h2 className="text-xl font-semibold text-gray-800 mb-4 flex items-center">
                  <List className="h-5 w-5 mr-2 text-indigo-600" />
                  Daily Log Overview
                </h2>

                {logEntries.length === 0 && (
                  <p className="text-gray-500 italic p-4 border-2 border-dashed border-gray-200 rounded-lg">
                    No entries yet. Start recording and save your first log!
                  </p>
                )}

                <div className="space-y-4 max-h-96 overflow-y-auto">
                  {logEntries.map((entry) => (
                    <div
                      key={entry.id}
                      className="log-entry p-4 bg-indigo-50 border-l-4 border-indigo-500 rounded-lg shadow-sm hover:shadow-md"
                    >
                      <p className="text-sm text-gray-600 mb-1">
                        {entry.createdAt.toLocaleDateString()} at {entry.createdAt.toLocaleTimeString()}
                      </p>
                      <p className="text-gray-800 leading-relaxed whitespace-pre-wrap">{entry.text}</p>
                    </div>
                  ))}
                </div>
              </section>

            </div>
          );
        };

        // Render the App
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('root');
            if (container) {
                const root = createRoot(container);
                root.render(<App />);
            }
        });
    </script>
</body>
</html>
